# Постановка задачи:
Кейс: Проектирование уведомительной системы

Необходимо спроектировать архитектуру для модуля уведомлений, который должен:
1. Отправлять уведомления пользователям через разные каналы (email, SMS, push, Telegram)
2. Иметь возможность добавления новых каналов без изменения ядра системы
3. Поддерживать шаблонизацию сообщений и локализацию
4. Обрабатывать ошибки отправки и реализовывать повторные попытки
5. Хранить историю отправленных уведомлений

Что нужно предоставить:
1. Краткое описание архитектуры (200-300 слов): основные компоненты и их взаимодействие
2. Опишите декларативную конфигурацию модуля как вы её видите
3. Интерфейсы ключевых классов/компонентов (достаточно 2-3 основных интерфейсов)
4. Краткое описание того, как система будет масштабироваться при росте нагрузки

# Решение:
Если мы говорим о целостной системе (которая должна быть реализована с "нуля"), то это можно реализовать на одном из современных фреймворков (Symfony, Laravel). С моей точки зрения Symfony наилучшим образом подходит для реализации данного кейса. Потому что в этом фреймворке достаточно неплохо реализована работа с воркерами и очередями + разные други фичи (события, кеширование, логгирование, удобство конфигурирования и т.п.).

Если речь идет о модуле уведомлений к уже существующей системе, то в этом случае нужно смотреть на политику построения данной системы. И уже потом принимать конкретные решения по структуре и непосредственной реализации кода данного модуля.

## Но в любом случае примерная архитектура данного кейса будет реализована по следующей схеме:

### **1. Краткое описание архитектуры**

Архитектура уведомительной системы строится по принципу расширяемости и модульности. В её центре находится компонент `NotificationService`, принимающий запросы на отправку уведомлений. Он взаимодействует с `ChannelManager`, который выбирает нужный канал доставки (email, SMS, push, Telegram и др.) на основе конфигурации и предпочтений пользователя.

Каждый канал реализует общий интерфейс `NotificationChannelInterface`, что позволяет легко добавлять новые каналы без изменения логики ядра. Для шаблонизации и локализации используется реализация интерфейса `TemplateEngineInterface`, которая формирует окончательное сообщение на нужном языке, подставляя переменные и тексты.

Уведомления ставятся в очередь (например, через Redis и/или Laravel Queue), и обрабатываются воркерами. Повторные попытки отправки реализуются средствами очередей, с сохранением статуса и ошибок в `NotificationLog`, который также отвечает за хранение истории.

Ошибки отправки фиксируются и могут инициировать повторные попытки с экспоненциальной задержкой, для уменьшения нагрузки на сервер. Все сообщения логируются в БД с указанием канала, статуса, получателя, времени отправки и ошибок (если они есть).

### **2. Пример декларативной конфигурации (YAML или PHP массив, в зависимости от пути реализации)**

```yaml
channels:
  email:
    class: App\Notifications\Channels\EmailChannel
    retries: 3
    enabled: true

  telegram:
    class: App\Notifications\Channels\TelegramChannel
    token: '%env(TELEGRAM_BOT_TOKEN)%'
    retries: 2
    enabled: true

  sms:
    class: App\Notifications\Channels\SmsChannel
    provider: twilio
    retries: 5
    enabled: false
```
### **3. Интерфейсы ключевых компонентов**

```php
interface NotificationChannelInterface {
    public function send(NotificationMessage $message): NotificationResult;
}

class NotificationMessage {
    public string $recipient;
    public string $template;
    public array $data;
    public string $locale;
    public string $channel;
}

class NotificationResult {
    public bool $success;
    public ?string $errorMessage;
    public DateTime $timestamp;
}
```

```php
interface TemplateEngineInterface {
    public function render(string $template, array $data, string $locale): string;
}
```
### **4. Масштабирование**

Система масштабируется горизонтально за счёт очередей: при увеличении нагрузки запускается больше воркеров, обрабатывающих уведомления параллельно. Каналы могут использовать асинхронные SDK (например, Guzzle, Firebase, Twilio) для отправки сообщений. Компоненты канального уровня изолированы, что позволяет масштабировать их независимо. В будущем можно использовать отдельные микросервисы на каждый канал при критичной нагрузке.

Также возможна интеграция с Kafka или RabbitMQ для распределения нагрузки между сервисами и отдельными сервисами логирования/аналитики.
